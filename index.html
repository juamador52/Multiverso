<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiverso: √ìrbitas</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: #000;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    h1 {
      font-size: 3.5rem;
      letter-spacing: 2px;
      text-align: center;
      margin-top: 40px;
      text-shadow: 0 0 20px #66aaff, 0 0 40px #66aaff;
      animation: brillar 2s infinite alternate;
      position: relative;
      z-index: 10;
    }

    @keyframes brillar {
      from { text-shadow: 0 0 20px #66aaff; }
      to { text-shadow: 0 0 40px #66aaff, 0 0 80px #66aaff; }
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      cursor: grab;
    }

    #canvas-container:active {
      cursor: grabbing;
    }

    #button-container {
      position: fixed;
      top: 50%; 
      right: 30px; 
      transform: translateY(-50%); 
      display: flex;
      flex-direction: column; 
      gap: 20px; 
      z-index: 20;  
    }

    .glow-button {
      padding: 12px 24px;
      font-size: 1rem;
      font-weight: bold;
      color: #66aaff;
      background-color: transparent;
      border: 2px solid #66aaff;
      border-radius: 8px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease-in-out;
      animation: glow-button 1.5s infinite alternate;
    }

    .glow-button:hover {
      background-color: #66aaff;
      color: #000;
      box-shadow: 0 0 20px #66aaff, 0 0 40px #66aaff, 0 0 60px #66aaff;
      animation: none;  
    }

    @keyframes glow-button {
      from {
        box-shadow: 0 0 5px #66aaff, 0 0 10px #66aaff;
        text-shadow: 0 0 5px #66aaff;
      }
      to {
        box-shadow: 0 0 10px #66aaff, 0 0 20px #66aaff;
        text-shadow: 0 0 10px #66aaff;
      }
    }

    #custom-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 99;
      display: none; 
      justify-content: center;
      align-items: center;
    }

    #custom-prompt-box {
      background: #111;
      border: 2px solid #66aaff;
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 0 30px #66aaff;
      z-index: 100;
      width: 300px;
      text-align: center;
    }

    #custom-prompt-box label {
      display: block;
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    #custom-prompt-box input {
      width: 90%;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #66aaff;
      background: #222;
      color: #fff;
      font-size: 1rem;
      margin-bottom: 20px;
    }

    #custom-prompt-box button {
      padding: 10px 20px;
      border-radius: 5px;
      border: 1px solid #66aaff;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      margin: 0 10px;
    }

    #prompt-ok {
      background: #66aaff;
      color: #000;
    }
    #prompt-ok:hover {
      background: #fff;
    }

    #prompt-cancel {
      background: transparent;
      color: #66aaff;
    }
    #prompt-cancel:hover {
      background: #333;
    }

    #console-output {
      position: fixed;
      bottom: 20px;
      left: 20px;
      max-width: 400px;
      max-height: 200px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #66aaff;
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9rem;
      z-index: 20;
      box-shadow: 0 0 20px #66aaff;
    }

    #console-output::-webkit-scrollbar {
      width: 8px;
    }

    #console-output::-webkit-scrollbar-track {
      background: #111;
    }

    #console-output::-webkit-scrollbar-thumb {
      background: #66aaff;
      border-radius: 4px;
    }

    .console-line {
      margin: 2px 0;
      color: #66aaff;
    }
  </style>
</head>
<body>
  <h1>üåå Multiverso: √ìrbitas üåå</h1>
  
  <div id="button-container">
    <button id="btn-insertar" class="glow-button">Insertar</button>
    <button id="btn-eliminar" class="glow-button">Eliminar</button>
    <button id="btn-buscar" class="glow-button">Buscar</button>
    <button id="btn-obtener-id" class="glow-button">Obtener ID</button>
  </div>

  <div id="canvas-container"></div>

  <div id="console-output"></div>

  <div id="custom-prompt-overlay">
    <div id="custom-prompt-box">
      <label id="prompt-label">Valor:</label>
      <input type="text" id="prompt-input">
      <button id="prompt-ok">Aceptar</button>
      <button id="prompt-cancel">Cancelar</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    function consoleLog(mensaje) {
      const consoleOutput = document.getElementById('console-output');
      const line = document.createElement('div');
      line.className = 'console-line';
      line.textContent = mensaje;
      consoleOutput.appendChild(line);
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
      console.log(mensaje);
    }
    
    class Nodo {
      constructor(dato = null, vacio = true) {
        this.Dato = dato;
        this.Vacio = vacio;
        this.Siguiente = null;
        this.Anterior = null;
        this.Orb_Anterior = null;
        this.Orb_Siguiente = null;
        this.Mesh_3D = null;
      }
    }

    class Orbita {
      constructor(capacidad = 3) {
        if (capacidad <= 2) {
          throw new Error("La capacidad debe ser mayor a 2");
        }
        this.Capacidad = capacidad;
        this.Nodos = [];
        this.Final = null;
        this.Tama√±o = 0;
        for (let i = 0; i < 3; i++) {
          this.Agregar_Nodo(null, true);
        }
      }

      Agregar_Nodo(dato, vacio = false) {
        if (!vacio) {
          for (const n of this.Nodos) {
            if (n.Vacio) {
              n.Dato = dato;
              n.Vacio = false;
              return true;
            }
          }
        }
        
        if (this.Nodos.length >= this.Capacidad) {
          return false;
        }
        
        const nuevo = new Nodo(dato, vacio);
        if (this.Nodos.length === 0) {
        } else {
          const primero = this.Nodos[0];
          const ultimo = this.Final;
          nuevo.Anterior = ultimo;
          nuevo.Siguiente = primero;
          ultimo.Siguiente = nuevo;
          primero.Anterior = nuevo;
        }

        this.Final = nuevo;
        this.Nodos.push(nuevo);
        this.Tama√±o = this.Nodos.length;
        return true;
      }

      Obtener_Nodo(posicion) {
        if (this.Nodos.length === 0) {
          return null;
        }
        posicion = ((posicion % this.Nodos.length) + this.Nodos.length) % this.Nodos.length;
        return this.Nodos[posicion];
      }

      Mostrar() {
        const datos = this.Nodos.map(n => String(n.Dato));
        return `[${datos.join(", ")}]`;
      }
    }

    class Sistema_Orbitas {
      constructor(capacidad = 3) {
        this.Orbitas = [];
        this.Capacidad = capacidad;
        this.Contador = 0;
        try {
          this.Crear_Orbita(capacidad);
        } catch (e) {
          consoleLog("Error al crear la √≥rbita: " + e.message);
          throw e;
        }
      }

      Crear_Orbita(capacidad) {
        const nueva = new Orbita(capacidad);
        
        if (this.Orbitas.length > 0) {
          const anterior = this.Orbitas[this.Orbitas.length - 1];
          anterior.Final.Orb_Siguiente = nueva.Nodos[0];
          nueva.Final.Orb_Anterior = anterior.Nodos[0];
        }
        this.Orbitas.push(nueva);
      }

      Insertar(dato) {
        if (this.Orbitas.length === 0) {
          this.Crear_Orbita(this.Capacidad);
        }
        
        const actual = this.Orbitas[this.Orbitas.length - 1];
        if (!actual.Agregar_Nodo(dato)) {
          const nueva_cap = actual.Capacidad + 1;
          this.Crear_Orbita(nueva_cap);
          this.Orbitas[this.Orbitas.length - 1].Agregar_Nodo(dato);
        }
        this.Contador += 1;
      }

      Obtener_Id(num_orbita, posicion) {
        if (num_orbita < 0 || num_orbita >= this.Orbitas.length) {
          throw new Error("El n√∫mero de √≥rbita no es v√°lido");
        }

        const orb = this.Orbitas[num_orbita];
        if (orb.Nodos.length === 0) {
          throw new Error("La √≥rbita est√° vac√≠a");
        }

        const indice = ((posicion % orb.Nodos.length) + orb.Nodos.length) % orb.Nodos.length;
        const id_base = this.Orbitas.slice(0, num_orbita).reduce((sum, o) => sum + o.Nodos.length, 0);
        const id_final = id_base + indice + 1;
        return id_final;
      }

      Convertir_Id(id_nodo) {
        if (id_nodo < 1 || id_nodo > this.Contador) {
          throw new Error("El id indicado no existe");
        }

        let acumulado = 0;
        for (let i = 0; i < this.Orbitas.length; i++) {
          const orb = this.Orbitas[i];
          if (id_nodo <= acumulado + orb.Nodos.length) {
            const pos = id_nodo - acumulado - 1;
            return [i, pos];
          }
          acumulado += orb.Nodos.length;
        }
        throw new Error("Id fuera de rango");
      }

      Obtener(...args) {
        if (args.length === 1) {
          const id_nodo = args[0];
          const [num_orbita, pos] = this.Convertir_Id(id_nodo);
          return this.Obtener(num_orbita, pos);
        } else if (args.length === 2) {
          const [num_orbita, pos] = args;
          if (num_orbita < 0 || num_orbita >= this.Orbitas.length) {
            throw new Error("El n√∫mero de √≥rbita no es v√°lido");
          }
          const orb = this.Orbitas[num_orbita];
          return orb.Obtener_Nodo(pos);
        } else {
          throw new Error("Par√°metros inv√°lidos");
        }
      }

      Eliminar_Orbita(num_orbita = -1) {
        if (this.Orbitas.length === 0) {
          return false;
        }

        const total_orbitas = this.Orbitas.length;
        
        if (num_orbita < 0) {
          num_orbita = total_orbitas - 1;
        }

        if (num_orbita >= total_orbitas) {
          throw new Error("El n√∫mero de √≥rbita no es v√°lido");
        }
        if (num_orbita > 0) {
          const orb_anterior = this.Orbitas[num_orbita - 1];
          orb_anterior.Final.Orb_Siguiente = null;
        }
        for (let i = num_orbita; i < this.Orbitas.length; i++) {
          this.Contador -= this.Orbitas[i].Nodos.length;
        }
        this.Orbitas = this.Orbitas.slice(0, num_orbita);
        return true;
      }

      Eliminar_Nodo(id_nodo) {
        const [num_orbita, pos] = this.Convertir_Id(id_nodo);
        const orb = this.Orbitas[num_orbita];
        const nodo = orb.Obtener_Nodo(pos);
        if (orb.Nodos.length <= 3) {
          if (orb.Nodos.slice(0, 3).every(n => n.Vacio)) {
            return "La √≥rbita est√° vac√≠a";
          }
          nodo.Dato = null;
          nodo.Vacio = true;
          this.Contador--;
          return true;
        }
        orb.Nodos.splice(pos, 1);
        orb.Final = orb.Nodos.length > 0 ? orb.Nodos[orb.Nodos.length - 1] : null;
        orb.Tama√±o = orb.Nodos.length;
        if (orb.Nodos.length > 0) {
          for (let i = 0; i < orb.Nodos.length; i++) {
            const n = orb.Nodos[i];
            n.Siguiente = orb.Nodos[(i + 1) % orb.Nodos.length];
            n.Anterior = orb.Nodos[(i - 1 + orb.Nodos.length) % orb.Nodos.length];
          }
          orb.Final = orb.Nodos[orb.Nodos.length - 1];
        }
        if (num_orbita > 0) {
          const orb_anterior = this.Orbitas[num_orbita - 1];
          orb.Nodos[0].Orb_Anterior = orb_anterior.Final;
          orb_anterior.Final.Orb_Siguiente = orb.Nodos[0];
        } else {
          orb.Nodos[0].Orb_Anterior = null;
        }

        if (num_orbita + 1 < this.Orbitas.length) {
          const orb_siguiente = this.Orbitas[num_orbita + 1];
          orb.Final.Orb_Siguiente = orb_siguiente.Nodos[0];
          orb_siguiente.Nodos[0].Orb_Anterior = orb.Final;
        } else {
          orb.Final.Orb_Siguiente = null;
        }

        this.Contador -= 1;
        return true;
      }

      Mostrar() {
        let texto = "";
        this.Orbitas.forEach((o, i) => {
          texto += `√ìrbita ${i} (cap ${o.Capacidad}): ${o.Mostrar()}\n`;
        });
        return texto.trim();
      }

      
    }

    function showCustomPrompt(label, defaultValue = "") {
      const overlay = document.getElementById('custom-prompt-overlay');
      const labelEl = document.getElementById('prompt-label');
      const inputEl = document.getElementById('prompt-input');
      const okBtn = document.getElementById('prompt-ok');
      const cancelBtn = document.getElementById('prompt-cancel');

      labelEl.textContent = label;
      inputEl.value = defaultValue;
      overlay.style.display = 'flex';
      inputEl.focus();
      inputEl.select();

      return new Promise((resolve) => {
        const onOk = () => {
          overlay.style.display = 'none';
          cleanup();
          resolve(inputEl.value);
        };

        const onCancel = () => {
          overlay.style.display = 'none';
          cleanup();
          resolve(null);
        };

        const onKey = (e) => {
          if (e.key === 'Enter') onOk();
          if (e.key === 'Escape') onCancel();
        };

        okBtn.onclick = onOk;
        cancelBtn.onclick = onCancel;
        inputEl.onkeydown = onKey;

        function cleanup() {
          okBtn.onclick = null;
          cancelBtn.onclick = null;
          inputEl.onkeydown = null;
        }
      });
    }

    let sistema;

    async function Iniciar_Sistema() {
      consoleLog("Creando sistema de √≥rbitas...");
      
      let cantidad_orbitas_str = await showCustomPrompt("Capacidad 1ra √≥rbita (m√≠n 3):", "6");
      if (cantidad_orbitas_str === null) cantidad_orbitas_str = "6";
      
      let cantidad_orbitas = parseInt(cantidad_orbitas_str) || 6;
      if (cantidad_orbitas < 3) cantidad_orbitas = 3;

      sistema = new Sistema_Orbitas(cantidad_orbitas);
      
      let cantidad_nodos_str = await showCustomPrompt("Nodos iniciales (m√≠n 3):", "36");
      if (cantidad_nodos_str === null) cantidad_nodos_str = "36";
      
      let cantidad_nodos = parseInt(cantidad_nodos_str) || 36;
      if (cantidad_nodos < 3) cantidad_nodos = 3;

      for (let i = 1; i <= cantidad_nodos; i++) {
        sistema.Insertar(i);
      }
      
      consoleLog("Sistema creado:");
      consoleLog(sistema.Mostrar());
    }

    window.onload = async () => {
      await Iniciar_Sistema();
      
      let nodo_actual_id = 1;
      let animacion_busqueda_activa = false;
      let nodo_seleccionado_mesh = null;
      let color_original_seleccionado = null;
      
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);
    
      const orbitGroup = new THREE.Group();
      scene.add(orbitGroup);

      const sunGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffff00, 
        emissive: 0xffff00, 
        emissiveIntensity: 0.5 
      });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      
      const colores_orbitas = [
        0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 
        0xff6b9d, 0xa8dadc, 0xc77dff, 0x90ee90
      ];

      const orbitas_3d = [];
      
      function Reconstruir_Escena_3D() {
        consoleLog("Reconstruyendo escena 3D...");
        
        while (orbitGroup.children.length > 0) {
          const obj = orbitGroup.children[0];
          orbitGroup.remove(obj);

          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(mat => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
        }
        orbitas_3d.length = 0;
        
        let id_counter = 0;
        nodo_seleccionado_mesh = null;

        orbitGroup.add(sun);

        sistema.Orbitas.forEach((orbita, index) => {
          const todos_vacios = orbita.Nodos.every(n => n.Vacio);
          if (todos_vacios) {
            consoleLog(`√ìrbita ${index} omitida (todos los nodos son null)`);
            return;
          }
          
          const radio = 2 + (index * 1.8);
          const color = colores_orbitas[index % colores_orbitas.length];
          
          const geometry = new THREE.RingGeometry(radio - 0.05, radio + 0.05, 128);
          const material = new THREE.MeshBasicMaterial({
            color: color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.5
          });
          const ring = new THREE.Mesh(geometry, material);
          ring.rotation.x = Math.PI / 2;
          orbitGroup.add(ring);

          const planetas = [];
          const nodos_visibles = orbita.Nodos.filter(n => !n.Vacio);
          const total_nodos_visibles = nodos_visibles.length;
          
          let indice_visible = 0;

          orbita.Nodos.forEach((nodo) => {
            if (!nodo.Vacio) {
              id_counter++;
              
              const angulo_base = (Math.PI * 2) / total_nodos_visibles;
              const planeta_geo = new THREE.SphereGeometry(0.2, 16, 16);
              const planeta_mat = new THREE.MeshBasicMaterial({  
                color: color,
                transparent: true,
                opacity: 0.9
              });
              const planeta = new THREE.Mesh(planeta_geo, planeta_mat);
              
              planeta.nodo_id = id_counter;
              planeta.original_color = new THREE.Color(color);
              
              const angulo = angulo_base * indice_visible;
              planeta.position.x = Math.cos(angulo) * radio;
              planeta.position.z = Math.sin(angulo) * radio;
              
              orbitGroup.add(planeta);
              planetas.push(planeta);
              
              nodo.Mesh_3D = planeta;
              
              if (id_counter === nodo_actual_id) {
                planeta.material.color.set(0xffffff);
                planeta.scale.set(1.5, 1.5, 1.5);
                nodo_seleccionado_mesh = planeta;
                color_original_seleccionado = planeta.original_color;
              }
              
              indice_visible++;
            } else {
              nodo.Mesh_3D = null;
            }
          });

          if (planetas.length > 0) {
            orbitas_3d.push({
              radio: radio,
              planetas: planetas,
              velocidad: (index % 2 === 0) ? 0.3 : -0.3,
              angulo_actual: 0
            });
          }
        });
        
        consoleLog("Estado del sistema:");
        consoleLog(sistema.Mostrar());
      }
      
      function Obtener_Mesh_Por_Id(id) {
        for (const obj of orbitGroup.children) {
          if (obj.isMesh && obj.nodo_id === id) {
            return obj;
          }
        }
        return null;
      }

      function Highlight_Nodo(mesh) {
        if (!mesh) return;
        
        if (nodo_seleccionado_mesh && nodo_seleccionado_mesh !== mesh) {
          if (color_original_seleccionado) {
            nodo_seleccionado_mesh.material.color.set(color_original_seleccionado);
          }
          nodo_seleccionado_mesh.scale.set(1, 1, 1);
        }

        nodo_seleccionado_mesh = mesh;
        color_original_seleccionado = mesh.original_color;
        mesh.material.color.set(0xffffff);
        mesh.scale.set(1.5, 1.5, 1.5);
        
        nodo_actual_id = mesh.nodo_id;
      }

      async function Manejar_Insertar() {
        consoleLog(">> Insertar nodo");
        
        let dato_str = await showCustomPrompt("Dato a insertar:", sistema.Contador + 1);
        if (dato_str === null) {
          consoleLog("Inserci√≥n cancelada");
          return;
        }
        
        let dato = parseInt(dato_str);
        if (isNaN(dato)) {
          dato = sistema.Contador + 1;
        }
        
        sistema.Insertar(dato);
        nodo_actual_id = sistema.Contador;
        
        consoleLog(`Nodo insertado con dato: ${dato}`);
        Reconstruir_Escena_3D();
      }

      async function Manejar_Eliminar() {
        consoleLog(">> Eliminar nodo");
        
        if (sistema.Contador === 0) {
          consoleLog("No hay nodos para eliminar");
          await showCustomPrompt("No hay nodos para eliminar.");
          return;
        }
        
        let id_str = await showCustomPrompt(`ID del nodo a eliminar (1 a ${sistema.Contador}):`);
        if (id_str === null) {
          consoleLog("Eliminaci√≥n cancelada");
          return;
        }

        let id_nodo = parseInt(id_str);
        if (isNaN(id_nodo)) {
          consoleLog("ID inv√°lido");
          return;
        }
        
        try {
          const resultado = sistema.Eliminar_Nodo(id_nodo);
          
          if (resultado === true) {
            consoleLog(`Nodo ${id_nodo} eliminado`);
            
            if (id_nodo === nodo_actual_id) {
              nodo_actual_id = 1;
            } else if (id_nodo < nodo_actual_id) {
              nodo_actual_id--;
            }
            
            Reconstruir_Escena_3D();
          } else {
            consoleLog(resultado);
          }
        } catch (e) {
          consoleLog("Error: " + e.message);
        }
      }

      async function Manejar_Buscar() {
        consoleLog(">> Buscar nodo");
        
        if (animacion_busqueda_activa) {
          consoleLog("Animaci√≥n de b√∫squeda ya en curso");
          return;
        }
        
        if (sistema.Contador === 0) {
          consoleLog("No hay nodos para buscar");
          await showCustomPrompt("No hay nodos para buscar.");
          return;
        }
        
        let id_str = await showCustomPrompt(`Buscar ID (1 a ${sistema.Contador}):`, 
          nodo_actual_id + 1 > sistema.Contador ? 1 : nodo_actual_id + 1);
        if (id_str === null) {
          consoleLog("B√∫squeda cancelada");
          return;
        }

        let id_nodo_destino = parseInt(id_str);
        if (isNaN(id_nodo_destino) || id_nodo_destino < 1 || id_nodo_destino > sistema.Contador) {
          consoleLog(`ID ${id_str} no es v√°lido`);
          await showCustomPrompt(`ID ${id_str} no es v√°lido.`);
          return;
        }
        
        if (id_nodo_destino === nodo_actual_id) {
          consoleLog("Ya est√°s en ese nodo");
          return;
        }

        animacion_busqueda_activa = true;
        let id_camino = nodo_actual_id;
        const step = 1;
        const tiempo_paso = 100;

        consoleLog(`Buscando de ${id_camino} a ${id_nodo_destino}...`);

        function proximo_paso() {
          id_camino += step;
          
          if (id_camino > sistema.Contador) {
            id_camino = 1;
          }
          
          let mesh_paso = Obtener_Mesh_Por_Id(id_camino);
          
          if (mesh_paso) {
            Highlight_Nodo(mesh_paso);
          }

          if (id_camino === id_nodo_destino) {
            consoleLog(`B√∫squeda finalizada en ID: ${id_camino}`);
            nodo_actual_id = id_camino;
            animacion_busqueda_activa = false;
          } else {
            setTimeout(proximo_paso, tiempo_paso);
          }
        }
        
        setTimeout(proximo_paso, tiempo_paso);
      }


      async function Manejar_Obtener_Id() {
        consoleLog(">> Obtener ID de posici√≥n");
        
        if (sistema.Orbitas.length === 0) {
          consoleLog("No hay √≥rbitas");
          return;
        }

        let orbita_str = await showCustomPrompt(`N√∫mero de √≥rbita (0 a ${sistema.Orbitas.length - 1}):`);
        if (orbita_str === null) {
          consoleLog("Operaci√≥n cancelada");
          return;
        }

        let num_orbita = parseInt(orbita_str);
        if (isNaN(num_orbita) || num_orbita < 0 || num_orbita >= sistema.Orbitas.length) {
          consoleLog("N√∫mero de √≥rbita inv√°lido");
          return;
        }

        let pos_str = await showCustomPrompt(`Posici√≥n en √≥rbita (0 a ${sistema.Orbitas[num_orbita].Nodos.length - 1}):`);
        if (pos_str === null) {
          consoleLog("Operaci√≥n cancelada");
          return;
        }

        let posicion = parseInt(pos_str);
        if (isNaN(posicion)) {
          consoleLog("Posici√≥n inv√°lida");
          return;
        }

        try {
          const id = sistema.Obtener_Id(num_orbita, posicion);
          const nodo = sistema.Obtener(num_orbita, posicion);
          consoleLog(`√ìrbita ${num_orbita}, Posici√≥n ${posicion} ‚Üí ID: ${id}, Dato: ${nodo.Dato}`);
          
          const mesh = Obtener_Mesh_Por_Id(id);
          if (mesh) {
            Highlight_Nodo(mesh);
            nodo_actual_id = id;
          }
        } catch (e) {
          consoleLog("Error: " + e.message);
        }
      }

      document.getElementById('btn-insertar').addEventListener('click', Manejar_Insertar);
      document.getElementById('btn-eliminar').addEventListener('click', Manejar_Eliminar);
      document.getElementById('btn-buscar').addEventListener('click', Manejar_Buscar);
      document.getElementById('btn-obtener-id').addEventListener('click', Manejar_Obtener_Id);

      Reconstruir_Escena_3D();
    
      camera.position.z = 20;
      camera.position.y = 0;
    
      let isDragging = false;
      let previousMouseX = 0;
      let previousMouseY = 0;
      let rotationX = 0;
      let rotationY = 0;
    
      renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMouseX = e.clientX;
        previousMouseY = e.clientY;
      });

      renderer.domElement.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const deltaX = e.clientX - previousMouseX;
          const deltaY = e.clientY - previousMouseY;
          
          rotationY += deltaX * 0.005;
          rotationX += deltaY * 0.005;
          
          rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
          
          previousMouseX = e.clientX;
          previousMouseY = e.clientY;
        }
      });

      renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
      });

      renderer.domElement.addEventListener('mouseleave', () => {
        isDragging = false;
      });

      let previousTouchX = 0;
      let previousTouchY = 0;

      renderer.domElement.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          isDragging = true;
          previousTouchX = e.touches[0].clientX;
          previousTouchY = e.touches[0].clientY;
        }
      });

      renderer.domElement.addEventListener('touchmove', (e) => {
        if (isDragging && e.touches.length === 1) {
          const deltaX = e.touches[0].clientX - previousTouchX;
          const deltaY = e.touches[0].clientY - previousTouchY;
          
          rotationY += deltaX * 0.005;
          rotationX += deltaY * 0.005;
          
          rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
          
          previousTouchX = e.touches[0].clientX;
          previousTouchY = e.touches[0].clientY;
          
          e.preventDefault();
        }
      }, { passive: false });

      renderer.domElement.addEventListener('touchend', () => {
        isDragging = false;
      });

      renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        const zoomSpeed = 1;
        const delta = e.deltaY > 0 ? 1 : -1;
        
        camera.position.z += delta * zoomSpeed;
        camera.position.z = Math.max(5, Math.min(50, camera.position.z));
      }, { passive: false });
    
      function animate() {
        requestAnimationFrame(animate);
        
        const delta_time = 0.01;
        
        orbitas_3d.forEach(orbita_info => {
          orbita_info.angulo_actual += orbita_info.velocidad * delta_time;
          
          const angulo_base = (Math.PI * 2) / orbita_info.planetas.length;

          orbita_info.planetas.forEach((planeta, idx) => {
            const angulo_offset = angulo_base * idx;
            const angulo = orbita_info.angulo_actual + angulo_offset;
            
            planeta.position.x = Math.cos(angulo) * orbita_info.radio;
            planeta.position.z = Math.sin(angulo) * orbita_info.radio;
          });
        });
        
        orbitGroup.rotation.y = rotationY;
        orbitGroup.rotation.x = rotationX;
        
        renderer.render(scene, camera);
      }
    
      animate();
    
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    };
  </script>

</html>

